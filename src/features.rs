use anyhow::{Context, Result};
use std::fs;
use std::path::Path;

use crate::{BuildSystem, PackageManager};

/// Detects the project's build system by looking for common build files in the repository root.
///
/// # Returns
///
/// `Ok(Some(BuildSystem::CMake))` if `CMakeLists.txt` is present, `Ok(Some(BuildSystem::Makefile))` if `Makefile` is present, or `Ok(None)` if neither file is found.
///
/// # Examples
///
/// ```
/// let _ = detect_build_system();
/// ```
pub fn detect_build_system() -> Result<Option<BuildSystem>> {
	if Path::new("CMakeLists.txt").exists() {
		Ok(Some(BuildSystem::CMake))
	} else if Path::new("Makefile").exists() {
		Ok(Some(BuildSystem::Makefile))
	} else {
		Ok(None)
	}
}

/// Detects whether a supported package manager is configured in the current project directory.
///
/// Checks for Conan manifests (`conanfile.txt` or `conanfile.py`) and vcpkg manifest (`vcpkg.json`)
/// and returns the corresponding `PackageManager` when found.
///
/// # Returns
///
/// `Ok(Some(PackageManager::Conan))` if a Conan manifest exists, `Ok(Some(PackageManager::Vcpkg))` if a vcpkg manifest exists, `Ok(None)` if no supported package manager is detected.
///
/// # Examples
///
/// ```no_run
/// let pm = crate::features::detect_package_manager().unwrap();
/// match pm {
///     Some(crate::PackageManager::Conan) => println!("Conan detected"),
///     Some(crate::PackageManager::Vcpkg) => println!("vcpkg detected"),
///     None => println!("No package manager configured"),
/// }
/// ```
pub fn detect_package_manager() -> Result<Option<PackageManager>> {
	if Path::new("conanfile.txt").exists() || Path::new("conanfile.py").exists() {
		Ok(Some(PackageManager::Conan))
	} else if Path::new("vcpkg.json").exists() {
		Ok(Some(PackageManager::Vcpkg))
	} else {
		Ok(None)
	}
}

/// Convert the project's build system by removing the source system's files (if present)
/// and generating the target system's build file based on the inferred project language.
///
/// Attempts to infer the project's language from its structure, removes the old build file
/// corresponding to `from` if it exists, and writes the generated build file for `to`.
///
/// # Arguments
///
/// * `from` - The current build system to replace. Must differ from `to`.
/// * `to` - The target build system to generate.
/// * `project_name` - The project name to embed in the generated build file.
///
/// # Returns
///
/// `Ok(())` on success. Returns an error if `from == to`, language detection fails, or any I/O/generation step fails.
///
/// # Examples
///
/// ```
/// # use anyhow::Result;
/// # fn example() -> Result<()> {
/// crate::features::convert_build_system(crate::BuildSystem::Makefile, crate::BuildSystem::CMake, "demo")?;
/// # Ok(())
/// # }
/// ```
pub fn convert_build_system(from: BuildSystem, to: BuildSystem, project_name: &str) -> Result<()> {
	if from == to {
		anyhow::bail!("Project already uses {}. No conversion needed.", to);
	}

	let language = crate::languages::Language::from_project_structure()?;

	// Remove old build system file
	match from {
		BuildSystem::Makefile => {
			if Path::new("Makefile").exists() {
				fs::remove_file("Makefile").context("Failed to remove old Makefile")?;
				println!("âœ“ Removed Makefile");
			}
		}
		BuildSystem::CMake => {
			if Path::new("CMakeLists.txt").exists() {
				fs::remove_file("CMakeLists.txt").context("Failed to remove old CMakeLists.txt")?;
				println!("âœ“ Removed CMakeLists.txt");
			}
		}
	}

	// Generate new build system file
	let generator = crate::get_generator(to);
	let build_file_content = generator.generate_build_file(language, project_name);
	fs::write(generator.extension(), build_file_content)
		.context("Failed to write new build system file")?;

	println!("âœ“ Successfully converted project from {} to {}", from, to);
	Ok(())
}

/// Adds a package manager configuration file to the current project.
///
/// If the same package manager is already configured, the function returns an error.
/// If a different package manager is present, a warning is printed and the new manager's
/// manifest is added alongside the existing one. The manifest file and any install
/// instructions are generated by the package manager generator for `pm`.
///
/// # Examples
///
/// ```
/// # use anyhow::Result;
/// # use crate::PackageManager;
/// # fn example() -> Result<()> {
/// add_package_manager_to_project(PackageManager::Conan, "my_project")?;
/// # Ok(())
/// # }
/// ```
///
/// # Returns
///
/// `Ok(())` on success, `Err` if writing the manifest fails or if the project already
/// uses the same package manager.
pub fn add_package_manager_to_project(pm: PackageManager, project_name: &str) -> Result<()> {
	// Check if package manager already exists
	if let Ok(Some(existing)) = detect_package_manager() {
		if existing == pm {
			anyhow::bail!("Project already uses {}. No changes needed.", pm);
		} else {
			println!(
				"âš ï¸  Warning: Project already has {} configured. Adding {} as well.",
				existing, pm
			);
		}
	}

	let pm_generator = crate::get_package_manager_generator(pm);
	let manifest = pm_generator.generate_manifest(project_name);
	fs::write(pm_generator.extension(), manifest)
		.with_context(|| format!("Failed to write {} manifest", pm_generator.name()))?;

	println!("âœ“ Generated {} configuration", pm);
	println!(
		"ðŸ“ Next steps: {}",
		pm_generator.generate_install_instructions()
	);

	Ok(())
}

/// Remove the specified package manager's manifest/configuration file from the project.
///
/// This deletes the file identified by the package manager's generator (e.g., `conanfile.txt`, `vcpkg.json`).
///
/// # Errors
///
/// Returns an error if the package manager's configuration file is not found in the project or if removing the file fails.
///
/// # Examples
///
/// ```no_run
/// use crate::PackageManager;
/// # fn main() -> anyhow::Result<()> {
/// crate::features::remove_package_manager_from_project(PackageManager::Conan)?;
/// # Ok(())
/// # }
/// ```
pub fn remove_package_manager_from_project(pm: PackageManager) -> Result<()> {
	let pm_generator = crate::get_package_manager_generator(pm);

	if !Path::new(pm_generator.extension()).exists() {
		anyhow::bail!(
			"{} not found in project. Nothing to remove.",
			pm_generator.name()
		);
	}

	fs::remove_file(pm_generator.extension())
		.with_context(|| format!("Failed to remove {} file", pm_generator.name()))?;

	println!("âœ“ Removed {} configuration", pm);
	Ok(())
}

/// Prints detected project features.
///
/// Detects and prints the build system and package manager (if any) and reports the presence
/// of common project files and directories: `src`, `.vscode`, `.gitignore`, and `.clang-format`.
///
/// # Examples
///
/// ```
/// # use anyhow::Result;
/// # fn main() -> Result<()> {
/// list_features()?;
/// # Ok(())
/// # }
/// ```
pub fn list_features() -> Result<()> {
	println!("\nðŸ“¦ Project Features:");
	println!("====================\n");

	// Build system
	match detect_build_system()? {
		Some(bs) => println!("  Build System:     {}", bs),
		None => println!("  Build System:     (none detected)"),
	}

	// Package manager
	match detect_package_manager()? {
		Some(pm) => println!("  Package Manager:  {}", pm),
		None => println!("  Package Manager:  (none configured)"),
	}

	// Project structure
	let has_src = Path::new("src").exists();
	let has_vscode = Path::new(".vscode").exists();
	let has_gitignore = Path::new(".gitignore").exists();
	let has_clang_format = Path::new(".clang-format").exists();

	println!("  Src directory:    {}", if has_src { "âœ“" } else { "âœ—" });
	println!("  VSCode config:    {}", if has_vscode { "âœ“" } else { "âœ—" });
	println!(
		"  .gitignore:       {}",
		if has_gitignore { "âœ“" } else { "âœ—" }
	);
	println!(
		"  .clang-format:    {}",
		if has_clang_format { "âœ“" } else { "âœ—" }
	);

	println!("\n");
	Ok(())
}